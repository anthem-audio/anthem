/*
    Copyright (C) 2021 Joshua Wade

    This file is part of Anthem.

    Anthem is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Anthem is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Anthem. If not, see <https://www.gnu.org/licenses/>.
*/

use std::collections::HashMap;

use crate::commands::command::Command;
use crate::model::{generator::Controller, generator::Instrument, project::Project, store::Reply};

fn remove_generator(project: &mut Project, id: u64) {
    project
        .generator_list
        .retain(|generator_id| *generator_id != id);
    project
        .instruments
        .retain(|instrument_id, _| *instrument_id != id);
    project
        .controllers
        .retain(|controller_id, _| *controller_id != id);
}

// Takes a vector of replies and produces a vector of replies that only
// contains one reply of each type. This will cause data loss unless all
// replies of the same type also contain the same data.
//
// This is meant to be used for journal pages. Each journal page will be
// processed with the same request ID, so this will work as long as the
// replies generated by the journal page don't have any additional data.
fn collapse_replies(replies: Vec<Reply>) -> Vec<Reply> {
    let mut replies_map = HashMap::new();
    
    replies.into_iter().for_each(|reply| {
        let reply_type = std::mem::discriminant(&reply);
        replies_map.insert(reply_type, reply);
    });

    replies_map.into_values().collect()
}

pub struct JournalPage {
    pub commands: Vec<Box<dyn Command>>,
}

impl Command for JournalPage {
    fn execute(&self, project: &mut Project, request_id: u64) -> Vec<Reply> {
        let mut all_replies = Vec::new();
        self.commands.iter().for_each(|command| {
            let replies = command.execute(project, request_id);
            replies.into_iter().for_each(|reply| {
                all_replies.push(reply);
            });
        });
        collapse_replies(all_replies)
    }

    fn rollback(&self, project: &mut Project, request_id: u64) -> Vec<Reply> {
        let mut all_replies = Vec::new();
        self.commands.iter().rev().for_each(|command| {
            let replies = command.rollback(project, request_id);
            replies.into_iter().for_each(|reply| {
                all_replies.push(reply);
            });
        });
        collapse_replies(all_replies)
    }
}

pub struct AddInstrumentCommand {
    pub id: u64,
    pub name: String,
}

impl Command for AddInstrumentCommand {
    fn execute(&self, project: &mut Project, request_id: u64) -> Vec<Reply> {
        project.generator_list.push(self.id);
        project.instruments.insert(
            self.id,
            Instrument {
                id: self.id,
                name: self.name.clone(),
            },
        );
        vec![Reply::InstrumentAdded(request_id)]
    }

    fn rollback(&self, project: &mut Project, request_id: u64) -> Vec<Reply> {
        remove_generator(project, self.id);
        vec![Reply::GeneratorRemoved(request_id)]
    }
}

pub struct AddControllerCommand {
    pub id: u64,
    pub name: String,
}

impl Command for AddControllerCommand {
    fn execute(&self, project: &mut Project, request_id: u64) -> Vec<Reply> {
        project.generator_list.push(self.id);
        project.controllers.insert(
            self.id,
            Controller {
                id: self.id,
                name: self.name.clone(),
            },
        );
        vec![Reply::ControllerAdded(request_id)]
    }

    fn rollback(&self, project: &mut Project, request_id: u64) -> Vec<Reply> {
        remove_generator(project, self.id);
        vec![Reply::GeneratorRemoved(request_id)]
    }
}
